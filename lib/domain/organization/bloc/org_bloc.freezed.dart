// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'org_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$OrganizationEvent {
  AddressModel get addressModel => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  double get deliveryPrice => throw _privateConstructorUsedError;
  Uint8List get logoImage => throw _privateConstructorUsedError;
  Uint8List get cardImage => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddressModel addressModel, String name,
            double deliveryPrice, Uint8List logoImage, Uint8List cardImage)
        createNew,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AddressModel addressModel, String name,
            double deliveryPrice, Uint8List logoImage, Uint8List cardImage)?
        createNew,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddressModel addressModel, String name,
            double deliveryPrice, Uint8List logoImage, Uint8List cardImage)?
        createNew,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_$OrganizationCreateNewEvent value) createNew,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_$OrganizationCreateNewEvent value)? createNew,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_$OrganizationCreateNewEvent value)? createNew,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $OrganizationEventCopyWith<OrganizationEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrganizationEventCopyWith<$Res> {
  factory $OrganizationEventCopyWith(
          OrganizationEvent value, $Res Function(OrganizationEvent) then) =
      _$OrganizationEventCopyWithImpl<$Res, OrganizationEvent>;
  @useResult
  $Res call(
      {AddressModel addressModel,
      String name,
      double deliveryPrice,
      Uint8List logoImage,
      Uint8List cardImage});
}

/// @nodoc
class _$OrganizationEventCopyWithImpl<$Res, $Val extends OrganizationEvent>
    implements $OrganizationEventCopyWith<$Res> {
  _$OrganizationEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addressModel = null,
    Object? name = null,
    Object? deliveryPrice = null,
    Object? logoImage = null,
    Object? cardImage = null,
  }) {
    return _then(_value.copyWith(
      addressModel: null == addressModel
          ? _value.addressModel
          : addressModel // ignore: cast_nullable_to_non_nullable
              as AddressModel,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      deliveryPrice: null == deliveryPrice
          ? _value.deliveryPrice
          : deliveryPrice // ignore: cast_nullable_to_non_nullable
              as double,
      logoImage: null == logoImage
          ? _value.logoImage
          : logoImage // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      cardImage: null == cardImage
          ? _value.cardImage
          : cardImage // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_$OrganizationCreateNewEventCopyWith<$Res>
    implements $OrganizationEventCopyWith<$Res> {
  factory _$$_$OrganizationCreateNewEventCopyWith(
          _$_$OrganizationCreateNewEvent value,
          $Res Function(_$_$OrganizationCreateNewEvent) then) =
      __$$_$OrganizationCreateNewEventCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {AddressModel addressModel,
      String name,
      double deliveryPrice,
      Uint8List logoImage,
      Uint8List cardImage});
}

/// @nodoc
class __$$_$OrganizationCreateNewEventCopyWithImpl<$Res>
    extends _$OrganizationEventCopyWithImpl<$Res,
        _$_$OrganizationCreateNewEvent>
    implements _$$_$OrganizationCreateNewEventCopyWith<$Res> {
  __$$_$OrganizationCreateNewEventCopyWithImpl(
      _$_$OrganizationCreateNewEvent _value,
      $Res Function(_$_$OrganizationCreateNewEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addressModel = null,
    Object? name = null,
    Object? deliveryPrice = null,
    Object? logoImage = null,
    Object? cardImage = null,
  }) {
    return _then(_$_$OrganizationCreateNewEvent(
      addressModel: null == addressModel
          ? _value.addressModel
          : addressModel // ignore: cast_nullable_to_non_nullable
              as AddressModel,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      deliveryPrice: null == deliveryPrice
          ? _value.deliveryPrice
          : deliveryPrice // ignore: cast_nullable_to_non_nullable
              as double,
      logoImage: null == logoImage
          ? _value.logoImage
          : logoImage // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      cardImage: null == cardImage
          ? _value.cardImage
          : cardImage // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$_$OrganizationCreateNewEvent
    with DiagnosticableTreeMixin
    implements _$OrganizationCreateNewEvent {
  const _$_$OrganizationCreateNewEvent(
      {required this.addressModel,
      required this.name,
      required this.deliveryPrice,
      required this.logoImage,
      required this.cardImage});

  @override
  final AddressModel addressModel;
  @override
  final String name;
  @override
  final double deliveryPrice;
  @override
  final Uint8List logoImage;
  @override
  final Uint8List cardImage;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'OrganizationEvent.createNew(addressModel: $addressModel, name: $name, deliveryPrice: $deliveryPrice, logoImage: $logoImage, cardImage: $cardImage)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'OrganizationEvent.createNew'))
      ..add(DiagnosticsProperty('addressModel', addressModel))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('deliveryPrice', deliveryPrice))
      ..add(DiagnosticsProperty('logoImage', logoImage))
      ..add(DiagnosticsProperty('cardImage', cardImage));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_$OrganizationCreateNewEvent &&
            (identical(other.addressModel, addressModel) ||
                other.addressModel == addressModel) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.deliveryPrice, deliveryPrice) ||
                other.deliveryPrice == deliveryPrice) &&
            const DeepCollectionEquality().equals(other.logoImage, logoImage) &&
            const DeepCollectionEquality().equals(other.cardImage, cardImage));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      addressModel,
      name,
      deliveryPrice,
      const DeepCollectionEquality().hash(logoImage),
      const DeepCollectionEquality().hash(cardImage));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_$OrganizationCreateNewEventCopyWith<_$_$OrganizationCreateNewEvent>
      get copyWith => __$$_$OrganizationCreateNewEventCopyWithImpl<
          _$_$OrganizationCreateNewEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddressModel addressModel, String name,
            double deliveryPrice, Uint8List logoImage, Uint8List cardImage)
        createNew,
  }) {
    return createNew(addressModel, name, deliveryPrice, logoImage, cardImage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(AddressModel addressModel, String name,
            double deliveryPrice, Uint8List logoImage, Uint8List cardImage)?
        createNew,
  }) {
    return createNew?.call(
        addressModel, name, deliveryPrice, logoImage, cardImage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddressModel addressModel, String name,
            double deliveryPrice, Uint8List logoImage, Uint8List cardImage)?
        createNew,
    required TResult orElse(),
  }) {
    if (createNew != null) {
      return createNew(addressModel, name, deliveryPrice, logoImage, cardImage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_$OrganizationCreateNewEvent value) createNew,
  }) {
    return createNew(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_$OrganizationCreateNewEvent value)? createNew,
  }) {
    return createNew?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_$OrganizationCreateNewEvent value)? createNew,
    required TResult orElse(),
  }) {
    if (createNew != null) {
      return createNew(this);
    }
    return orElse();
  }
}

abstract class _$OrganizationCreateNewEvent implements OrganizationEvent {
  const factory _$OrganizationCreateNewEvent(
      {required final AddressModel addressModel,
      required final String name,
      required final double deliveryPrice,
      required final Uint8List logoImage,
      required final Uint8List cardImage}) = _$_$OrganizationCreateNewEvent;

  @override
  AddressModel get addressModel;
  @override
  String get name;
  @override
  double get deliveryPrice;
  @override
  Uint8List get logoImage;
  @override
  Uint8List get cardImage;
  @override
  @JsonKey(ignore: true)
  _$$_$OrganizationCreateNewEventCopyWith<_$_$OrganizationCreateNewEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$OrganizationState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() initial,
    required TResult Function(OrganizationModel model) loaded,
    required TResult Function(String errorTitle, String errorSubtitle) errored,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? initial,
    TResult? Function(OrganizationModel model)? loaded,
    TResult? Function(String errorTitle, String errorSubtitle)? errored,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? initial,
    TResult Function(OrganizationModel model)? loaded,
    TResult Function(String errorTitle, String errorSubtitle)? errored,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_$OrganizationLoadingState value) loading,
    required TResult Function(_$OrganizationInitialState value) initial,
    required TResult Function(_$OrganizationLoadedState value) loaded,
    required TResult Function(_$OrganizationErroredState value) errored,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_$OrganizationLoadingState value)? loading,
    TResult? Function(_$OrganizationInitialState value)? initial,
    TResult? Function(_$OrganizationLoadedState value)? loaded,
    TResult? Function(_$OrganizationErroredState value)? errored,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_$OrganizationLoadingState value)? loading,
    TResult Function(_$OrganizationInitialState value)? initial,
    TResult Function(_$OrganizationLoadedState value)? loaded,
    TResult Function(_$OrganizationErroredState value)? errored,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrganizationStateCopyWith<$Res> {
  factory $OrganizationStateCopyWith(
          OrganizationState value, $Res Function(OrganizationState) then) =
      _$OrganizationStateCopyWithImpl<$Res, OrganizationState>;
}

/// @nodoc
class _$OrganizationStateCopyWithImpl<$Res, $Val extends OrganizationState>
    implements $OrganizationStateCopyWith<$Res> {
  _$OrganizationStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_$OrganizationLoadingStateCopyWith<$Res> {
  factory _$$_$OrganizationLoadingStateCopyWith(
          _$_$OrganizationLoadingState value,
          $Res Function(_$_$OrganizationLoadingState) then) =
      __$$_$OrganizationLoadingStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_$OrganizationLoadingStateCopyWithImpl<$Res>
    extends _$OrganizationStateCopyWithImpl<$Res, _$_$OrganizationLoadingState>
    implements _$$_$OrganizationLoadingStateCopyWith<$Res> {
  __$$_$OrganizationLoadingStateCopyWithImpl(
      _$_$OrganizationLoadingState _value,
      $Res Function(_$_$OrganizationLoadingState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_$OrganizationLoadingState
    with DiagnosticableTreeMixin
    implements _$OrganizationLoadingState {
  const _$_$OrganizationLoadingState();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'OrganizationState.loading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'OrganizationState.loading'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_$OrganizationLoadingState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() initial,
    required TResult Function(OrganizationModel model) loaded,
    required TResult Function(String errorTitle, String errorSubtitle) errored,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? initial,
    TResult? Function(OrganizationModel model)? loaded,
    TResult? Function(String errorTitle, String errorSubtitle)? errored,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? initial,
    TResult Function(OrganizationModel model)? loaded,
    TResult Function(String errorTitle, String errorSubtitle)? errored,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_$OrganizationLoadingState value) loading,
    required TResult Function(_$OrganizationInitialState value) initial,
    required TResult Function(_$OrganizationLoadedState value) loaded,
    required TResult Function(_$OrganizationErroredState value) errored,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_$OrganizationLoadingState value)? loading,
    TResult? Function(_$OrganizationInitialState value)? initial,
    TResult? Function(_$OrganizationLoadedState value)? loaded,
    TResult? Function(_$OrganizationErroredState value)? errored,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_$OrganizationLoadingState value)? loading,
    TResult Function(_$OrganizationInitialState value)? initial,
    TResult Function(_$OrganizationLoadedState value)? loaded,
    TResult Function(_$OrganizationErroredState value)? errored,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _$OrganizationLoadingState implements OrganizationState {
  const factory _$OrganizationLoadingState() = _$_$OrganizationLoadingState;
}

/// @nodoc
abstract class _$$_$OrganizationInitialStateCopyWith<$Res> {
  factory _$$_$OrganizationInitialStateCopyWith(
          _$_$OrganizationInitialState value,
          $Res Function(_$_$OrganizationInitialState) then) =
      __$$_$OrganizationInitialStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_$OrganizationInitialStateCopyWithImpl<$Res>
    extends _$OrganizationStateCopyWithImpl<$Res, _$_$OrganizationInitialState>
    implements _$$_$OrganizationInitialStateCopyWith<$Res> {
  __$$_$OrganizationInitialStateCopyWithImpl(
      _$_$OrganizationInitialState _value,
      $Res Function(_$_$OrganizationInitialState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_$OrganizationInitialState
    with DiagnosticableTreeMixin
    implements _$OrganizationInitialState {
  const _$_$OrganizationInitialState();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'OrganizationState.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'OrganizationState.initial'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_$OrganizationInitialState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() initial,
    required TResult Function(OrganizationModel model) loaded,
    required TResult Function(String errorTitle, String errorSubtitle) errored,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? initial,
    TResult? Function(OrganizationModel model)? loaded,
    TResult? Function(String errorTitle, String errorSubtitle)? errored,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? initial,
    TResult Function(OrganizationModel model)? loaded,
    TResult Function(String errorTitle, String errorSubtitle)? errored,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_$OrganizationLoadingState value) loading,
    required TResult Function(_$OrganizationInitialState value) initial,
    required TResult Function(_$OrganizationLoadedState value) loaded,
    required TResult Function(_$OrganizationErroredState value) errored,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_$OrganizationLoadingState value)? loading,
    TResult? Function(_$OrganizationInitialState value)? initial,
    TResult? Function(_$OrganizationLoadedState value)? loaded,
    TResult? Function(_$OrganizationErroredState value)? errored,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_$OrganizationLoadingState value)? loading,
    TResult Function(_$OrganizationInitialState value)? initial,
    TResult Function(_$OrganizationLoadedState value)? loaded,
    TResult Function(_$OrganizationErroredState value)? errored,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _$OrganizationInitialState implements OrganizationState {
  const factory _$OrganizationInitialState() = _$_$OrganizationInitialState;
}

/// @nodoc
abstract class _$$_$OrganizationLoadedStateCopyWith<$Res> {
  factory _$$_$OrganizationLoadedStateCopyWith(
          _$_$OrganizationLoadedState value,
          $Res Function(_$_$OrganizationLoadedState) then) =
      __$$_$OrganizationLoadedStateCopyWithImpl<$Res>;
  @useResult
  $Res call({OrganizationModel model});
}

/// @nodoc
class __$$_$OrganizationLoadedStateCopyWithImpl<$Res>
    extends _$OrganizationStateCopyWithImpl<$Res, _$_$OrganizationLoadedState>
    implements _$$_$OrganizationLoadedStateCopyWith<$Res> {
  __$$_$OrganizationLoadedStateCopyWithImpl(_$_$OrganizationLoadedState _value,
      $Res Function(_$_$OrganizationLoadedState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
  }) {
    return _then(_$_$OrganizationLoadedState(
      null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as OrganizationModel,
    ));
  }
}

/// @nodoc

class _$_$OrganizationLoadedState
    with DiagnosticableTreeMixin
    implements _$OrganizationLoadedState {
  const _$_$OrganizationLoadedState(this.model);

  @override
  final OrganizationModel model;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'OrganizationState.loaded(model: $model)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'OrganizationState.loaded'))
      ..add(DiagnosticsProperty('model', model));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_$OrganizationLoadedState &&
            (identical(other.model, model) || other.model == model));
  }

  @override
  int get hashCode => Object.hash(runtimeType, model);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_$OrganizationLoadedStateCopyWith<_$_$OrganizationLoadedState>
      get copyWith => __$$_$OrganizationLoadedStateCopyWithImpl<
          _$_$OrganizationLoadedState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() initial,
    required TResult Function(OrganizationModel model) loaded,
    required TResult Function(String errorTitle, String errorSubtitle) errored,
  }) {
    return loaded(model);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? initial,
    TResult? Function(OrganizationModel model)? loaded,
    TResult? Function(String errorTitle, String errorSubtitle)? errored,
  }) {
    return loaded?.call(model);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? initial,
    TResult Function(OrganizationModel model)? loaded,
    TResult Function(String errorTitle, String errorSubtitle)? errored,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(model);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_$OrganizationLoadingState value) loading,
    required TResult Function(_$OrganizationInitialState value) initial,
    required TResult Function(_$OrganizationLoadedState value) loaded,
    required TResult Function(_$OrganizationErroredState value) errored,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_$OrganizationLoadingState value)? loading,
    TResult? Function(_$OrganizationInitialState value)? initial,
    TResult? Function(_$OrganizationLoadedState value)? loaded,
    TResult? Function(_$OrganizationErroredState value)? errored,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_$OrganizationLoadingState value)? loading,
    TResult Function(_$OrganizationInitialState value)? initial,
    TResult Function(_$OrganizationLoadedState value)? loaded,
    TResult Function(_$OrganizationErroredState value)? errored,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _$OrganizationLoadedState implements OrganizationState {
  const factory _$OrganizationLoadedState(final OrganizationModel model) =
      _$_$OrganizationLoadedState;

  OrganizationModel get model;
  @JsonKey(ignore: true)
  _$$_$OrganizationLoadedStateCopyWith<_$_$OrganizationLoadedState>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_$OrganizationErroredStateCopyWith<$Res> {
  factory _$$_$OrganizationErroredStateCopyWith(
          _$_$OrganizationErroredState value,
          $Res Function(_$_$OrganizationErroredState) then) =
      __$$_$OrganizationErroredStateCopyWithImpl<$Res>;
  @useResult
  $Res call({String errorTitle, String errorSubtitle});
}

/// @nodoc
class __$$_$OrganizationErroredStateCopyWithImpl<$Res>
    extends _$OrganizationStateCopyWithImpl<$Res, _$_$OrganizationErroredState>
    implements _$$_$OrganizationErroredStateCopyWith<$Res> {
  __$$_$OrganizationErroredStateCopyWithImpl(
      _$_$OrganizationErroredState _value,
      $Res Function(_$_$OrganizationErroredState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorTitle = null,
    Object? errorSubtitle = null,
  }) {
    return _then(_$_$OrganizationErroredState(
      null == errorTitle
          ? _value.errorTitle
          : errorTitle // ignore: cast_nullable_to_non_nullable
              as String,
      null == errorSubtitle
          ? _value.errorSubtitle
          : errorSubtitle // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_$OrganizationErroredState
    with DiagnosticableTreeMixin
    implements _$OrganizationErroredState {
  const _$_$OrganizationErroredState(this.errorTitle, this.errorSubtitle);

  @override
  final String errorTitle;
  @override
  final String errorSubtitle;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'OrganizationState.errored(errorTitle: $errorTitle, errorSubtitle: $errorSubtitle)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'OrganizationState.errored'))
      ..add(DiagnosticsProperty('errorTitle', errorTitle))
      ..add(DiagnosticsProperty('errorSubtitle', errorSubtitle));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_$OrganizationErroredState &&
            (identical(other.errorTitle, errorTitle) ||
                other.errorTitle == errorTitle) &&
            (identical(other.errorSubtitle, errorSubtitle) ||
                other.errorSubtitle == errorSubtitle));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorTitle, errorSubtitle);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_$OrganizationErroredStateCopyWith<_$_$OrganizationErroredState>
      get copyWith => __$$_$OrganizationErroredStateCopyWithImpl<
          _$_$OrganizationErroredState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() initial,
    required TResult Function(OrganizationModel model) loaded,
    required TResult Function(String errorTitle, String errorSubtitle) errored,
  }) {
    return errored(errorTitle, errorSubtitle);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? initial,
    TResult? Function(OrganizationModel model)? loaded,
    TResult? Function(String errorTitle, String errorSubtitle)? errored,
  }) {
    return errored?.call(errorTitle, errorSubtitle);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? initial,
    TResult Function(OrganizationModel model)? loaded,
    TResult Function(String errorTitle, String errorSubtitle)? errored,
    required TResult orElse(),
  }) {
    if (errored != null) {
      return errored(errorTitle, errorSubtitle);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_$OrganizationLoadingState value) loading,
    required TResult Function(_$OrganizationInitialState value) initial,
    required TResult Function(_$OrganizationLoadedState value) loaded,
    required TResult Function(_$OrganizationErroredState value) errored,
  }) {
    return errored(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_$OrganizationLoadingState value)? loading,
    TResult? Function(_$OrganizationInitialState value)? initial,
    TResult? Function(_$OrganizationLoadedState value)? loaded,
    TResult? Function(_$OrganizationErroredState value)? errored,
  }) {
    return errored?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_$OrganizationLoadingState value)? loading,
    TResult Function(_$OrganizationInitialState value)? initial,
    TResult Function(_$OrganizationLoadedState value)? loaded,
    TResult Function(_$OrganizationErroredState value)? errored,
    required TResult orElse(),
  }) {
    if (errored != null) {
      return errored(this);
    }
    return orElse();
  }
}

abstract class _$OrganizationErroredState implements OrganizationState {
  const factory _$OrganizationErroredState(
          final String errorTitle, final String errorSubtitle) =
      _$_$OrganizationErroredState;

  String get errorTitle;
  String get errorSubtitle;
  @JsonKey(ignore: true)
  _$$_$OrganizationErroredStateCopyWith<_$_$OrganizationErroredState>
      get copyWith => throw _privateConstructorUsedError;
}
